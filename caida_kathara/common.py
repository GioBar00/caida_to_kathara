# Copyright 2018 ETH Zurich, Anapaya Systems
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Stdlib
from enum import Enum
from ipaddress import ip_address
from typing import Mapping, Tuple
from urllib.parse import urlsplit
import os
import subprocess

from caida_kathara.net import AddressProxy, NetworkDescription, IPNetwork


class ArgsBase:
    def __init__(self, args):
        for k, v in vars(args).items():
            setattr(self, k, v)

class ArgsCaidaDicts(ArgsBase):
    def __init__(self, args, caida_dicts):
        """
        :param object args: Contains the passed command line arguments as named attributes.
        :param dict caida_dicts: The generated topo dicts from TopoGenerator.
        """
        super().__init__(args)
        self.caida_dicts = caida_dicts


LinkRel = Enum('LinkRel', ['CUSTOMER', 'PROVIDER', 'PEER', 'SIBLING'])


def split_host_port(addr: str) -> Tuple[str, int]:
    parts = urlsplit('//' + addr)
    if parts.port is None:
        raise ValueError("missing port in addr: {}".format(addr))
    # first remove the port, and strip ipv6 brackets:
    ip = parts.netloc.rsplit(sep=':{}'.format(parts.port),
                             maxsplit=1)[0].strip('[]')
    return (ip, parts.port)


def join_host_port(host: str, port: int) -> str:
    ip = ip_address(host)
    if ip.version == 4:
        return '{}:{}'.format(host, port)
    return '[{}]:{}'.format(host, port)


def docker_image(args, image):
    if args.docker_registry:
        image = '%s/%s' % (args.docker_registry, image)
    if args.image_tag:
        image = '%s:%s' % (image, args.image_tag)
    return image


def docker_host(docker, addr=None):
    if docker or not addr:
        # Using docker topology or there is no default addr,
        # we directly get the DOCKER0 IP
        addr = docker_ip()
    return addr


def docker_ip():
    return subprocess.check_output(['tools/docker-ip']).decode("utf-8").strip()


def remote_nets(networks, topo_id):
    """
    Returns the subnets of all remote ASes the SIG in topo_id is connected to.
    :param networks dict: Scion elem to subnet/IP map.
    :param topo_id: A key of a topo dict generated by TopoGenerator.
    :return: String of comma separated subnets.
    """
    rem_nets = []
    for key in networks:
        if 'sig' in key and topo_id.file_fmt() not in key:
            rem_nets.append(str(networks[key][0]['net']))
    return ','.join(rem_nets)


def json_default(o):
    if isinstance(o, AddressProxy):
        return str(o.ip)
    raise TypeError
